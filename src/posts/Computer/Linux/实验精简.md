## 选填



### 熟悉目录以及文件相关命令

`cd`、`pwd`、`ls`、`mkdir`、`rmdir`、`rm`

说明：  mkdir 的-p选项使用场景；

说明：  rm -rf 的使用场景

说明：  ls -al ，ls /etc | more 的作用



文件显示：`cat`、`more`、`less`

文件复制、删除和移动：cp、rm、mv 

创建或改变文件时间标签：touch



### 熟练运行通配符

基于ls命令练习通配符（？、*、[]）的使用

1)	在当前目录下生成 touch t{1..10}.c 文件
2)	ls *.c 作用
3)	ls  ??.c作用
4)	ls t[1-5].c 的作用



### 统计查询

find、wc、sort、

cat、tee、last



### vi编辑器的使用

打开文件：vi [文件名]

命令模式（Command mode）：输入字符都作为命令来解释执行。不显示输入内容。

输入模式（Insert mode）：输入的任何字符都将作为文件内容被保存，并显示在屏幕上。

末行模式（Last line mode）：在屏幕最末行接收行命令输入，并执行。

练习3种工模间的切换



#### 退出相关命令

`:q`、`:wq`、`:q!`



#### 增删查改

iao、dd、dw、x

#### 修改/替换命令

:s/str1/str2/ 用字符串 str2 替换行中首次出现的字符串 str1

:s/str1/str2/g 用字符串 str2 替换行中所有出现的字符串 str1

:%s/str1/str2/g 用字符串 str2 替换所有行中，所有出现的字符串 str1



#### 复制与撤销

`y`、`p`、`J`、`u`、`Ctrl r`

| 命令                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| y1G                                                          | 复制游标所在行到第一行的所有数据                             |
| yG                                                           | 复制游标所在行到最后一行的所有数据                           |
| y0                                                           | 复制光标所在的那个字符到该行行首的所有数据                   |
| y$                                                           | 复制光标所在的那个字符到该行行尾的所有数据                   |
| p, P                                                         | p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) |
| J                                                            | 将光标所在行与下一行的数据结合成同一行                       |
| c                                                            | 重复删除多个数据，例如向下删除 10 行，[ 10cj ]               |
| u                                                            | 复原前一个动作。(常用)                                       |
| [Ctrl]+r                                                     | 重做上一个动作。(常用)                                       |
| 这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！ |                                                              |
| .                                                            | 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用) |







### 用户管理

用户相关文件

`/ect/passwd` `etc/shadow` `/etc/group`

查看用户账号文件―>/etc/passwd，说明其一行的格式及各域作用

```shell
用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell
```

查看影子文件―>/etc/shadow，说明其中一行的格式及各域作用

```shell
登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志
```

查看组文件―>/etc/group，说明其中一行的格式及各域作用

```shell
组名:口令:组标识号:组内用户列表
```



#### 用户相关命令

`useradd` `passwd` `su` `userdel` `usermod`

1)	练习添加新用户命令：useradd；
2)	练习设置用户口令命令：passwd；
3)	练习切换用户身份命令：su；
4)	练习删除用户命令：userdel；
5)	练习修改用户信息命令：usermod；



#### 组相关命令

`groupadd` `groupdel` `groupmod` `gpasswd`

1)	练习添加组命令：groupadd；
2)	练习删除组命令：groupdel；
3)	练习修改组信息命令：groupmod；
4)	添加/删除组成员：gpasswd；



#### 文件相关命令

`chmod` `chown` `chgrp`

1)	修改权限命令：chmod
2)	改变文件拥有者：chown；
3)	更改文件所属的组：chgrp；



### 进程管理与定时任务

`ps` `top` 

`kill` `killall` `jobs` `fg` `bg` `nice` `renice`

使用top命令，实时显示系统各个进程的资源占用情况。说明输出信息中列的含意。

在top基本视图中，按h键进入另一个视图。

在top基本视图中，按f键进入另一个视图，在这里可以编辑基本视图中的显示字段。

在top基本视图中，按c键进入另一个视图,可以显示进程的路径。

在top基本视图中，按k键，可以在不退出top命令的情况下杀死某个正在运行的进程。

在top基本视图中，按b键，高亮显示当前正在运行的进程。



### 压缩

`tar`

压缩 `tar -czvf`

解压 `tar -xzvf`



## 简答题：

### 什么是进程？

进程（process）是一个可并发执行的程序在一个数据集上的一次运行。（就是程序的一次运行过程）



### 进程与程序的区别？

- 程序是静态的概念，进程是动态的概念
- 程序可长期保存，进程有生命期和状态
- 进程包括程序，不同进程可对应同一程序代码



### 进程的三种状态？

- 运行态：进程占有CPU且正在运行；
- 就绪态：进程具备运行状态，等待系统分配CPU以便运行；
- 等待态：又叫阻塞态或睡眠态，指进程不具备运行条件，正在等待某个事件的完成；



### 如何后台启动进程？

- 在执行的命令后添加`$`符号



### fork函数的特点

- 一次调用，两次返回
- 父进程输出main,子进程输出child
- 使用gcc编译，并运行
- `fork()`系统调用，创建一个新的子进程





## 编程题



定时任务1

利用at设置一个任务自动化，在当天11：00钟，在根目录下自动创建一个abc目录，并进入到abc目录中，建立一个空的文件test，同时对该文件进行打包成test.tar;

```shell
at 11pm today
mkdir abc
cd abc
touch test
tar -czvf test.tar test
<EOT>
```



定时任务2

Cron应用：每周2,4,6早上3点重新启动系统

```shell
* * * * * myCommand # 每1分钟执行一次myCommand
crontab
0 3 * * 2,4,6 reboot # 每周2,4,6早上3点重新启动系统
# ctrl D 保存并退出
```



### Linux下GCC的使用

#### 多个文件编译

现在有 3 个文件，分别是 main.c，print.c，print.h

```sh
#1）多个文件一起编译：
gcc print.c main.c -o hello
# 执行生成文件

#2）分别编译各个源文件，再对编译后输出的目标文件（.o）链接
gcc -c print.c -o print.o
gcc -c main.c -o main.o
gcc print.o main.o -o hello
# 执行生成文件
```



如果头文件和源文件不在一同目录中，如何解决？

```sh
# 头文件所在目录：myInclude
 
# 主要是要加 -I 指定头文件目录：
gcc print.c main.c -o hello -I myInclude
# 运行文件
```



#### makefile（Makefile）

在使用gcc命令时，一个工程又有多个文件（比如100个文件），如果按照上述编译方法，往往需要输入很多指令，而且修改文件也不方便，因此引入makefile文件解决该问题。

```makefile
#main是需要生成的目标文件名，它依赖main.o print.o
main:main.o print.o
#gcc命令，生成main,语句前面要用TAB
	gcc main.o input.o cal.o -o main
#main.o是目标文件，依赖main.c文件，通过gcc -c main.c生成main.o文件
main.o:main.c
	gcc -c main.c
print.o:print.c
	gcc -c print.c
```



### Shell

```sh
#!/bin/bash
sum=0
for i in *.c
do
	# 输出总行数
	# lines=`wc -l < $i`
	# sum=`expr $sum + lines`
	
	# 输出.c文件个数
	sum=`expr $sum + 1`
done
echo $sum
```

