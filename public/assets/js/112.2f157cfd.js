(window.webpackJsonp=window.webpackJsonp||[]).push([[112],{704:function(s,t,n){"use strict";n.r(t);var a=n(1),e=Object(a.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* 涉及到的js/Node相关方法 */")]),s._v("\n\n  path"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("resolve")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'/foo/bar'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'./baz'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// node文档 返回: '/foo/bar/baz'")]),s._v("\n\n   "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n  * @param {number} start 指定修改的开始位置（从 0 计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位\n  * @param {number} deleteCount\n  * @param {string | number | object} item1,item2,itemN\n  * @return {array} 被删除的元素组成的一个数组\n  */")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("splice")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("start"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" deleteCount"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" item1"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" item2"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" itemN"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。")]),s._v("\n\n "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n  * @param {object} obj 要定义属性的对象\n  * @param {} prop 要定义或修改的属性的名称或Symbol\n  * @param {} descriptor 要定义或修改的属性描述符\n  * @return {} 被传递给函数的对象\n  */")]),s._v("\n  Object"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("defineProperty")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("obj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" prop"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" descriptor"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。")]),s._v("\n\n "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n  * @param {} value 需要检测的值\n  * @return {} 被传递给函数的对象\n  */")]),s._v("\n  Array"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("isArray")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("value"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 用于确定传递的值是否是一个 Array。")]),s._v("\n\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br"),t("span",{staticClass:"line-number"},[s._v("26")]),t("br"),t("span",{staticClass:"line-number"},[s._v("27")]),t("br")])]),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* Vue源码中的相关接口 */")]),s._v("\n\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n  * @param {} value 需要检测的值\n  * @return {} 被传递给函数的对象\n  */")]),s._v("\n  Array"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("isArray")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("value"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 用于确定传递的值是否是一个 Array。")]),s._v("\n\n  \n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* chatGPT的回答 */")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* 好的，让我来更详细地解释一下Vue的原理和机制，并结合源码来说明。\n  首先，Vue的核心是响应式数据绑定机制。当我们在组件中定义一个数据属性时，Vue会使用Object.defineProperty来劫持这个属性的getter和setter。这样当这个属性的值发生变化时，Vue能够自动检测到并触发视图更新。具体实现可以查看Vue源码中的observer.js文件，其中的Observer类负责将数据对象转化为响应式对象，Dep类负责管理数据属性和Watcher对象之间的依赖关系，Watcher类负责监听数据变化并调用相关的回调函数进行视图更新。\n  其次，Vue的组件化开发思想使得我们能够将一个复杂的UI界面拆分成多个小的组件。Vue的组件系统使用了一个叫做VNode的虚拟DOM来描述组件的结构和状态。当一个组件的状态发生变化时，Vue会使用VNode来比较新旧状态之间的差异，并且只更新需要更新的部分，从而提高了应用程序的性能。具体实现可以查看Vue源码中的vdom目录，其中的createPatchFunction函数负责将VNode转化为真实的DOM元素，并且在比较新旧状态时只更新需要更新的部分。\n  除了响应式数据绑定和组件化开发，Vue还提供了一些常用的指令和插件来简化Web应用程序的开发。比如v-if、v-for、v-bind等指令可以让我们在模板中轻松地使用条件判断、循环和数据绑定等功能。具体实现可以查看Vue源码中的compiler目录，其中的compileToFunctions函数负责将模板编译为渲染函数，渲染函数负责将数据和VNode进行关联。\n  总体来说，Vue的原理和机制非常复杂，涉及到响应式数据绑定、虚拟DOM、组件化开发、指令和插件等多个方面。理解这些机制可以让我们更好地使用Vue开发Web应用程序，并且从中获得更好的性能和可维护性。同时，深入阅读Vue源码也可以帮助我们更好地理解这些机制的实现细节。 */")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br")])]),t("h3",{attrs:{id:"vue源码分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue源码分析"}},[s._v("#")]),s._v(" Vue源码分析")]),s._v(" "),t("p",[s._v("对Vue源码，本人也在学习当中\n下面是一些github上大佬的解析")]),s._v(" "),t("h4",{attrs:{id:"关于"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于"}},[s._v("#")]),s._v(" 关于")]),s._v(" "),t("ul",[t("li",[s._v("Vue.js是一款MVVM框架，上手快速简单易用，通过响应式在修改数据的时候更新视图。- Vue.js的响应式原理依赖于Object.defineProperty，尤大大在Vue.js文档中就已经提到过，这也是Vue.js不支持IE8 以及更低版本浏览器的原因。Vue通过设定对象属性的 setter/getter 方法来监听数据的变化，通过getter进行依赖收集，而每个setter方法就是一个观察者，在数据变更的时候通知订阅者更新视图。————"),t("a",{attrs:{href:"https://github.com/answershuto/learnVue",target:"_blank",rel:"noopener noreferrer"}},[s._v("github"),t("OutboundLink")],1)])]),s._v(" "),t("p",[s._v("剖析github上某基友仿vue实现的mvvm库\n"),t("a",{attrs:{href:"https://github.com/DMQ/mvvm",target:"_blank",rel:"noopener noreferrer"}},[s._v("地址"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=e.exports}}]);