(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{617:function(_,v,t){"use strict";t.r(v);var s=t(1),a=Object(s.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"第一章-绪论"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第一章-绪论"}},[_._v("#")]),_._v(" 第一章 绪论")]),_._v(" "),v("h3",{attrs:{id:"软件生命周期-√"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#软件生命周期-√"}},[_._v("#")]),_._v(" 软件生命周期 √")]),_._v(" "),v("p",[_._v("软件生命周期：指软件产品从"),v("strong",[_._v("考虑其概念")]),_._v("开始，到该软件产品"),v("strong",[_._v("不再使用")]),_._v("为止的整个时期，一般包括"),v("strong",[_._v("概念")]),_._v("阶段、"),v("strong",[_._v("分析与设计")]),_._v("阶段、"),v("strong",[_._v("构造")]),_._v("阶段、"),v("strong",[_._v("移交和运行")]),_._v("阶段等不同时期。")]),_._v(" "),v("h3",{attrs:{id:"软件生命周期模型-√"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#软件生命周期模型-√"}},[_._v("#")]),_._v(" 软件生命周期模型 √")]),_._v(" "),v("h4",{attrs:{id:"定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[_._v("#")]),_._v(" 定义")]),_._v(" "),v("p",[_._v("软件生命周期模型：从一个"),v("strong",[_._v("特定角度")]),_._v("提出的对"),v("strong",[_._v("软件过程")]),_._v("的"),v("strong",[_._v("概括描述")]),_._v("，是对"),v("strong",[_._v("软件开发实际过程")]),_._v("的"),v("strong",[_._v("抽象")]),_._v("，包括构成软件过程的各种"),v("strong",[_._v("活动")]),_._v("、"),v("strong",[_._v("软件工件")]),_._v("以及"),v("strong",[_._v("参与角色")]),_._v("等。")]),_._v(" "),v("h4",{attrs:{id:"与开发方法的关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#与开发方法的关系"}},[_._v("#")]),_._v(" 与开发方法的关系")]),_._v(" "),v("h4",{attrs:{id:"种类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#种类"}},[_._v("#")]),_._v(" 种类")]),_._v(" "),v("p",[_._v("瀑布模型")]),_._v(" "),v("p",[_._v("增量模型")]),_._v(" "),v("p",[_._v("螺旋结构")]),_._v(" "),v("p",[_._v("喷泉模型")]),_._v(" "),v("p",[_._v("基于知识的模型")]),_._v(" "),v("p",[_._v("变换模型")]),_._v(" "),v("h4",{attrs:{id:"_1-瀑布模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-瀑布模型"}},[_._v("#")]),_._v(" 1. 瀑布模型")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305050944574.png",alt:"image-20230505094410772"}})]),_._v(" "),v("p",[_._v("瀑布模型：将软件生存周期的各项活动规定为依照固定顺序连接的若干阶段工作，最终得到 软件产品。")]),_._v(" "),v("p",[_._v("特点")]),_._v(" "),v("ol",[v("li",[_._v("阶段间具有顺序性和依赖性。")]),_._v(" "),v("li",[_._v("推迟实现的观点。")]),_._v(" "),v("li",[_._v("质量保证的观点\n"),v("ul",[v("li",[_._v("每个阶段必须完成规定的文档;")]),_._v(" "),v("li",[_._v("每个阶段结束前完成文档审查,")]),_._v(" "),v("li",[_._v("及早改正错误。")])])])]),_._v(" "),v("p",[_._v("瀑布模型优缺点：")]),_._v(" "),v("p",[_._v("1、瀑布模型的优点（强迫开发人员使用规范的方法，严格规定了每个阶段必须提交的文\n档，要求每个阶段）")]),_._v(" "),v("ul",[v("li",[_._v("可以强迫开发人员采用规范的方法;")]),_._v(" "),v("li",[_._v("严格规定了每个阶段必须提交的文档;")]),_._v(" "),v("li",[_._v("要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证。")])]),_._v(" "),v("p",[_._v("2、瀑布模型的缺点")]),_._v(" "),v("ul",[v("li",[_._v("在软件开发的初期阶段就要求做出正确、 全面、完整的需求分析对许多应用软件来说\n是极其困难的。")]),_._v(" "),v("li",[_._v("在需求分析阶段，当需求确定后，无法及时验证需求是否正确、完整。")]),_._v(" "),v("li",[_._v("作为整体开发的瀑布模型，由于不支持产品的演化，缺乏灵活性，对开发过程中很难\n发现的错误，只有在最终产品运行时才能暴露出来， 从而使软件产品难以维护")])]),_._v(" "),v("h4",{attrs:{id:"_2-增量模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-增量模型"}},[_._v("#")]),_._v(" 2. 增量模型")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305050946894.png",alt:"image-20230505094644540"}})]),_._v(" "),v("p",[_._v("增量模型：先完成一个系统子集的开发，再按同 样的开发步骤增加功能 (系统子集),如 此递增下去直至满足全部系统需求。")]),_._v(" "),v("p",[_._v("增量模型优缺点：")]),_._v(" "),v("p",[_._v("优点：")]),_._v(" "),v("ol",[v("li",[_._v("短时间内可提交完成部分功能")]),_._v(" "),v("li",[_._v("逐渐增加产品功能，用户适应产品快。")])]),_._v(" "),v("p",[_._v("缺点：")]),_._v(" "),v("ol",[v("li",[_._v("增量构件划分以及集成困难。")]),_._v(" "),v("li",[_._v("容易退化为边做边改模型。")])]),_._v(" "),v("h4",{attrs:{id:"_3-螺旋模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-螺旋模型"}},[_._v("#")]),_._v(" 3. 螺旋模型")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305050948202.png",alt:"image-20230505094813134"}})]),_._v(" "),v("p",[_._v("简化的螺旋模型")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305050949390.png",alt:"image-20230505094948557"}})]),_._v(" "),v("p",[_._v("螺旋模型：在每个阶段之前都增 加了风险分析 过程的快速原型模型。 看作增加了风险分析 的快速原型模型。")]),_._v(" "),v("p",[_._v("螺旋模型优缺点:\n优点：")]),_._v(" "),v("ol",[v("li",[_._v("利于把软件质量作为软件\n开发目标。")]),_._v(" "),v("li",[_._v("减少测试")]),_._v(" "),v("li",[_._v("维护和开发不分开")])]),_._v(" "),v("p",[_._v("缺点：")]),_._v(" "),v("ol",[v("li",[_._v("风险估计困难")])]),_._v(" "),v("h4",{attrs:{id:"_4-喷泉模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-喷泉模型"}},[_._v("#")]),_._v(" 4. 喷泉模型")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305050954674.png",alt:"image-20230505095441036"}})]),_._v(" "),v("p",[_._v("改进的喷泉模型")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305050955610.png",alt:"image-20230505095518806"}})]),_._v(" "),v("p",[_._v("喷泉模型：典型的"),v("strong",[_._v("面向对象软件过程模型")]),_._v("。 体现迭代和无缝的特性。")]),_._v(" "),v("h4",{attrs:{id:"_5-基于知识的模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-基于知识的模型"}},[_._v("#")]),_._v(" 5. 基于知识的模型")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305050958611.png",alt:"image-20230505095801703"}})]),_._v(" "),v("h4",{attrs:{id:"_6-变换模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-变换模型"}},[_._v("#")]),_._v(" 6. 变换模型")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305050959938.png",alt:"image-20230505095905166"}})]),_._v(" "),v("h2",{attrs:{id:"第二章-软件要求定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第二章-软件要求定义"}},[_._v("#")]),_._v(" 第二章 软件要求定义")]),_._v(" "),v("h3",{attrs:{id:"纯收入"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#纯收入"}},[_._v("#")]),_._v(" 纯收入")]),_._v(" "),v("p",[_._v("衡量工程价值的另一项经济指标是工程的纯收入，也就是在整个生命周期之内的系统累计经验效益（折合成现在值）之差。")]),_._v(" "),v("h3",{attrs:{id:"投资回收期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#投资回收期"}},[_._v("#")]),_._v(" 投资回收期")]),_._v(" "),v("p",[_._v("通常用投资回收期衡量一项开发工程的价值。所谓投资回收期就是使累计的经济效益等于最初投资所需要的时间。")]),_._v(" "),v("h3",{attrs:{id:"流程图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#流程图"}},[_._v("#")]),_._v(" 流程图")]),_._v(" "),v("h4",{attrs:{id:"流程图的三种结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#流程图的三种结构"}},[_._v("#")]),_._v(" 流程图的三种结构")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305052117001.png",alt:"image-20230505211729505"}}),v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305061358049.png",alt:"image-20230506135834972"}})]),_._v(" "),v("h3",{attrs:{id:"系统流程图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#系统流程图"}},[_._v("#")]),_._v(" 系统流程图")]),_._v(" "),v("p",[_._v("系统流程图：是一种描绘物理系统的图，用图形符号以黑盒子形式描绘物理系统的各部 件，"),v("strong",[_._v("表达数据在系统各部件之间流动的情况")]),_._v("。而不是对数据进行加工处理 的控制过程。")]),_._v(" "),v("p",[_._v("作用：描述物理系统的工具，用于可行性研究和需求分析阶段。")]),_._v(" "),v("h4",{attrs:{id:"系统流程图的符号"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#系统流程图的符号"}},[_._v("#")]),_._v(" 系统流程图的符号")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305071616622.png",alt:"image-20230507161645181"}}),v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305051013767.png",alt:"image-20230505101317158"}}),v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305051015538.png",alt:"image-20230505101502672"}})]),_._v(" "),v("h3",{attrs:{id:"需求分析问题识别（11种）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#需求分析问题识别（11种）"}},[_._v("#")]),_._v(" 需求分析问题识别（11种）")]),_._v(" "),v("ol",[v("li",[_._v("功能需求分析")]),_._v(" "),v("li",[_._v("性能需求分析")]),_._v(" "),v("li",[_._v("数据分析")]),_._v(" "),v("li",[_._v("环境需求分析")]),_._v(" "),v("li",[_._v("输入，输出分析")]),_._v(" "),v("li",[_._v("安全分析")]),_._v(" "),v("li",[_._v("文档分析")]),_._v(" "),v("li",[_._v("进度分析")]),_._v(" "),v("li",[_._v("资源分析")]),_._v(" "),v("li",[_._v("质量控制分析")]),_._v(" "),v("li",[_._v("界面需求分析")])]),_._v(" "),v("p",[_._v("扩展（了解）")]),_._v(" "),v("ol",[v("li",[_._v("需求冲突和矛盾：分析需求文档中的各个需求，检查是否存在冲突或矛盾的情况，例如一个需求要求系统具有 A 功能，而另一个需求却要求系统不具备 A 功能。识别这些冲突和矛盾，并与相关的利益相关者进行沟通和协商，以达成一致的需求。")]),_._v(" "),v("li",[_._v("遗漏的需求：仔细审查需求文档，与相关的利益相关者交流，以确保所有重要的需求都得到了充分的考虑。识别可能被遗漏或忽视的需求，并及时补充和完善。")]),_._v(" "),v("li",[_._v("模糊和不明确的需求：检查需求文档中是否存在模糊和不明确的表述，例如使用模糊的术语或描述。识别这些需求，并与相关的利益相关者一起澄清和明确需求的含义和预期结果。")]),_._v(" "),v("li",[_._v("不一致的需求：需求文档中的各个需求应该是一致的，相互之间不应该存在逻辑或信息上的矛盾。通过仔细审查和比较不同需求之间的关系，识别出不一致的需求，并与相关的利益相关者协商解决。")]),_._v(" "),v("li",[_._v("非功能性需求问题：除了功能性需求外，还要关注非功能性需求，如性能、安全性、可靠性等。检查需求文档中是否存在模糊、不明确或不可测量的非功能性需求，并进行澄清和具体化。")]),_._v(" "),v("li",[_._v("优先级和约束问题：评估需求的优先级和约束条件，确保它们合理和可实现。识别可能存在的冲突、无法实现的约束以及不合理的优先级安排，并与相关方进行协商和解决。")]),_._v(" "),v("li",[_._v("隐含需求问题：需求文档中可能存在一些隐含的需求，没有明确列出或讨论。通过与利益相关者的深入访谈和沟通，识别出可能存在的隐含需求，并确保它们被充分理解和考虑。")]),_._v(" "),v("li",[_._v("可行性问题：评估需求的可行性，包括技术、资源、时间和成本等方面的考虑。识别可能存在的无法实现或超出可行范围的需求，并与相关方进行讨论和调整。")]),_._v(" "),v("li",[_._v("可测量性问题：需求应该是可测量的，以便能够验证和验证系统是否满足需求。识别可能存在的无法测量或模糊的需求，并与相关方一起进行澄清和具体化。")]),_._v(" "),v("li",[_._v("不必要的需求：检查需求文档中是否存在重复、冗余或不必要的需求。识别这些不必要的需求，并与相关方进行讨论和删减，以简化需求并提高效率。")]),_._v(" "),v("li",[_._v("变更和迭代问题：需求是一个动态的过程，在需求分析过程中可能会出现变更和迭代。识别可能需要调整和修改的需求，并及时进行变更管理和沟通。")]),_._v(" "),v("li",[_._v("可理解性和可交付性问题：需求应该是清晰、具体和可理解的，以便开发团队能够准确理解和交付。识别可能存在的需求表述不清晰、缺乏细节或难以理解的问题，并与相关方进行澄清和明确。")])]),_._v(" "),v("h2",{attrs:{id:"第三章-软件设计"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第三章-软件设计"}},[_._v("#")]),_._v(" 第三章 软件设计")]),_._v(" "),v("h3",{attrs:{id:"耦合性和内聚性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#耦合性和内聚性"}},[_._v("#")]),_._v(" 耦合性和内聚性")]),_._v(" "),v("h4",{attrs:{id:"特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[_._v("#")]),_._v(" 特点")]),_._v(" "),v("h4",{attrs:{id:"定义-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定义-2"}},[_._v("#")]),_._v(" 定义")]),_._v(" "),v("h4",{attrs:{id:"强弱"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#强弱"}},[_._v("#")]),_._v(" 强弱")]),_._v(" "),v("h3",{attrs:{id:"模块间耦合类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模块间耦合类型"}},[_._v("#")]),_._v(" 模块间耦合类型")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305051334251.png",alt:"image-20230505133413946"}})]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("非直接耦合")]),_._v("：不直接联系。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("数据耦合")]),_._v("：通过"),v("strong",[_._v("数据参数")]),_._v("（注意 是参数，不是区域也不是子结构！）联系。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("标记耦合")]),_._v("：传递的信息是子结构（结构体、对象等）。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("控制耦合")]),_._v("：A模块控制B模块")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("外部耦合")]),_._v("：访问同一外部变量，与公共耦合不同的是，一个是区域，一个是变量。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("公共耦合")]),_._v("：访问同一公共区域")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("内容耦合")]),_._v("：内容重叠，")]),_._v(" "),v("ul",[v("li",[_._v("如果发生下列情形，两个模块之间就发生了内容耦合。\n"),v("ol",[v("li",[_._v("一个模块"),v("strong",[_._v("直接访问")]),_._v("另一个模块的"),v("strong",[_._v("内部数据")]),_._v("；")]),_._v(" "),v("li",[_._v("一个模块不通过正常入口转到另一模块内部；")]),_._v(" "),v("li",[_._v("两个模块有一部分程序"),v("strong",[_._v("代码重叠")]),_._v("(只可能出现在汇编语言中)；")]),_._v(" "),v("li",[_._v("一个模块有"),v("strong",[_._v("多个入口")]),_._v("。")])])])])])]),_._v(" "),v("h3",{attrs:{id:"模块的内聚性类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模块的内聚性类型"}},[_._v("#")]),_._v(" 模块的内聚性类型")]),_._v(" "),v("p",[_._v("模块间的耦合和模块的内聚是度量模块独立性的两个准则。内聚是模块功能强度的度量，即模块内部各个元素彼此结合的紧密程度。一个模块内部各元素之间的紧密程度越高，则其内聚性越高，模块独立性越好。")]),_._v(" "),v("p",[_._v("一般来讲，聚合类型共分七种， 以下为"),v("strong",[_._v("从弱到强")]),_._v("的排序：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305051345472.png",alt:"image-20230505134547257"}})]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("偶然内聚或巧合内聚")]),_._v("：指一个模块内的各处理元素之间没有任何联系。")]),_._v(" "),v("li",[v("strong",[_._v("逻辑内聚")]),_._v("：指模块内执行若干个逻辑上相似的功能，通过参数确定该模块完成哪一个功能。")]),_._v(" "),v("li",[v("strong",[_._v("时间内聚")]),_._v("：把需要同时执行的动作组合在一起形成的模块。")]),_._v(" "),v("li",[v("strong",[_._v("过程内聚")]),_._v("：指一个模块完成多个任务，这些任务必须按指定的次序执行。")]),_._v(" "),v("li",[v("strong",[_._v("通信内聚")]),_._v("：指模块内的所有处理元素都在同一数据结构上操作，或者各处理使用相同的输入数据或产生相同的输出数据。")]),_._v(" "),v("li",[v("strong",[_._v("顺序内聚")]),_._v("：指一个模块中的各个处理元素都密切相关于同一各功能且必须顺序执行，前一个功能元素的输出就是下一个功能的输入。")]),_._v(" "),v("li",[v("strong",[_._v("功能内聚")]),_._v("：指模块内的所有元素共同作用完成一个功能，缺一不可。")])]),_._v(" "),v("p",[_._v("总结： 容易混淆的是过程内聚和顺序内聚， 虽然都是按固定顺序执行， 但顺序内聚要求"),v("strong",[_._v("前一个功能的输出是下一个功能的输入")]),_._v("。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305051356440.png",alt:"image-20230505135632080"}})]),_._v(" "),v("h3",{attrs:{id:"软件结构准则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#软件结构准则"}},[_._v("#")]),_._v(" 软件结构准则")]),_._v(" "),v("h4",{attrs:{id:"算法描述（4种方法）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#算法描述（4种方法）"}},[_._v("#")]),_._v(" 算法描述（4种方法）")]),_._v(" "),v("ul",[v("li",[_._v("盒图（N-S图）")]),_._v(" "),v("li",[_._v("程序流程图")]),_._v(" "),v("li",[_._v("PAD图")]),_._v(" "),v("li",[_._v("自然语言描述")])]),_._v(" "),v("p",[_._v("扩展（了解）")]),_._v(" "),v("ol",[v("li",[_._v("自然语言描述算法：使用自然语言描述的好处是任何人都能看懂。当然相比于伪代码或者程序语言而言，使用自然语言描述有时会显得繁琐。")]),_._v(" "),v("li",[_._v("流程图描述算法：流程图（Flow Diagram）是一种通用的图形符号表示法是一种非正式的，可以清楚描述步骤和判断。")]),_._v(" "),v("li",[_._v("伪代码描述算法：伪代码（Pseudocode）是一种非正式的，类似于英语结构的，用于描述模块结构图的语言。")]),_._v(" "),v("li",[_._v("程序语言描述算法：程序语言描述算法，实际上就是用程序语言实现算法。不同的编程语言其语法不尽相同。")])]),_._v(" "),v("h4",{attrs:{id:"模块属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模块属性"}},[_._v("#")]),_._v(" 模块属性")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("接口")])]),_._v(" "),v("li",[v("strong",[_._v("功能")])]),_._v(" "),v("li",[v("strong",[_._v("逻辑")])]),_._v(" "),v("li",[v("strong",[_._v("状态")])])]),_._v(" "),v("p",[_._v("扩展（了解）")]),_._v(" "),v("ol",[v("li",[_._v("名称：模块的名称，通常是一个有意义的、描述性的名称，用于唯一标识和识别模块。")]),_._v(" "),v("li",[_._v("功能：模块所提供的具体功能或服务的描述，包括模块的输入、输出以及对外部系统或用户的交互方式。")]),_._v(" "),v("li",[_._v("接口：模块与其他模块或外部系统之间的交互接口，描述了模块的输入、输出、调用的函数或方法等信息。")]),_._v(" "),v("li",[_._v("数据结构：模块内部使用的数据结构，包括数据类型、变量、常量等的定义和描述。")]),_._v(" "),v("li",[_._v("依赖关系：模块与其他模块之间的依赖关系，描述了模块所依赖的其他模块或外部组件，以及被依赖的关系。")]),_._v(" "),v("li",[_._v("耦合度：模块与其他模块之间的耦合程度，描述了模块之间的关联程度和依赖程度，例如紧密耦合、松散耦合等。")]),_._v(" "),v("li",[_._v("内聚度：模块内部功能之间的相关性和一致性，描述了模块内部功能的组织和关联程度，例如高内聚、低内聚等。")]),_._v(" "),v("li",[_._v("复用性：模块的可重用程度，描述了模块是否可以在不同的系统或项目中进行复用，以提高开发效率和质量。")]),_._v(" "),v("li",[_._v("可测试性：模块的可测试程度，描述了模块是否易于进行单元测试、集成测试和功能测试等，以保证模块的质量和稳定性。")])]),_._v(" "),v("h2",{attrs:{id:"第五章-软件测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第五章-软件测试"}},[_._v("#")]),_._v(" 第五章 软件测试")]),_._v(" "),v("h3",{attrs:{id:"黑白盒测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#黑白盒测试"}},[_._v("#")]),_._v(" 黑白盒测试")]),_._v(" "),v("h4",{attrs:{id:"白盒方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#白盒方法"}},[_._v("#")]),_._v(" 白盒方法")]),_._v(" "),v("p",[v("strong",[_._v("逻辑覆盖")])]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("语句覆盖")]),_._v(":被测试程序中的每条语句至少执行一次。")]),_._v(" "),v("li",[v("strong",[_._v("判定覆盖")]),_._v(":使得被测程序中每个判定表达式至少获得一次“真”值和“假”值")]),_._v(" "),v("li",[v("strong",[_._v("条件覆盖")]),_._v(":使得判定表达式中每个条件的各种可能的值至少出现一次。")]),_._v(" "),v("li",[v("strong",[_._v("判定/条件覆盖")]),_._v(":使得判定表达式中的每个条件的所有可能取值至少出现一次，并使每个判定表达式所有可能的结果也至少出现一次。")]),_._v(" "),v("li",[v("strong",[_._v("条件组合覆盖")]),_._v(":设计足够多的测试用例，使得每个判定表达式中条件的各种可能 的值的组合都至少出现一次。")]),_._v(" "),v("li",[v("strong",[_._v("路径覆盖")]),_._v(":覆盖被测程序中所有可能的路径。")])]),_._v(" "),v("h5",{attrs:{id:"控制结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#控制结构"}},[_._v("#")]),_._v(" 控制结构")]),_._v(" "),v("p",[v("strong",[_._v("基本路径测试")])]),_._v(" "),v("p",[_._v("基本测试步骤")]),_._v(" "),v("ol",[v("li",[_._v("以详细设计或源程序为基础，到处程序流程图的拓扑结构——程序图")]),_._v(" "),v("li",[_._v("计算程序图G的环路复杂性V(G)")]),_._v(" "),v("li",[_._v("确定只包含独立路线的基本路径集")]),_._v(" "),v("li",[_._v("设计测试用例")])]),_._v(" "),v("p",[v("strong",[_._v("条件测试")])]),_._v(" "),v("p",[v("strong",[_._v("循环测试")])]),_._v(" "),v("h4",{attrs:{id:"黑盒方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#黑盒方法"}},[_._v("#")]),_._v(" 黑盒方法")]),_._v(" "),v("p",[v("strong",[_._v("等价类划分法")])]),_._v(" "),v("ol",[v("li",[_._v("把程序的输入数据集合按输入条件划分为若干个等价类，每一个等价类相对于输入条件表示为一组有效或无效的输入。")]),_._v(" "),v("li",[_._v("为每一等价类设计一个测试用例。")])]),_._v(" "),v("p",[_._v("划分等价类的规则：")]),_._v(" "),v("p",[_._v("(1)如果输入条件规定了取值范围，可定义一个有效等价类和两个无效等价类。")]),_._v(" "),v("p",[_._v("(2)如果输入条件代表集合的某个元素，则可定义一个有效等价类和一个无效等价类。")]),_._v(" "),v("p",[v("strong",[_._v("边界值分析法")])]),_._v(" "),v("ol",[v("li",[_._v("输入等价类和输出等价类的边界就是应该着重测试的程序边界情况。选取的测试数据应该刚好等于、刚好小于、刚好大于边界值")])]),_._v(" "),v("p",[v("strong",[_._v("错误推测法")])]),_._v(" "),v("h3",{attrs:{id:"系统测试（讲了一个）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#系统测试（讲了一个）"}},[_._v("#")]),_._v(" 系统测试（讲了一个）")]),_._v(" "),v("p",[_._v("系统测试：将子系统组装为一个完整的系统进行测试。子系统测试和系统测试总 称为“集成测试” 。")]),_._v(" "),v("p",[_._v("系统测试的特点：功能测试、性能测试、安全测试、回归测试")]),_._v(" "),v("h4",{attrs:{id:"集成测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#集成测试"}},[_._v("#")]),_._v(" 集成测试")]),_._v(" "),v("p",[_._v("目标：发现与接口有关的问题")]),_._v(" "),v("p",[_._v("实施者：独立的测试机构或第三方人员")]),_._v(" "),v("p",[_._v("集成方法：")]),_._v(" "),v("ol",[v("li",[_._v("非渐增测试")]),_._v(" "),v("li",[_._v("渐增测试\n"),v("ol",[v("li",[_._v("自顶向下集成:从主控模块开始,沿着程序的控制层次")]),_._v(" "),v("li",[_._v("自顶向下移动,逐步添加新的模块自底向上集成:从最底层模块开始组装")])])])]),_._v(" "),v("p",[_._v("自顶向下与自底向上相结合的方法：")]),_._v(" "),v("ol",[v("li",[_._v("上层模块使用自顶向下方法")]),_._v(" "),v("li",[_._v("下层模块采用自底向上方法")])]),_._v(" "),v("p",[_._v("回归测试: 重新执行已经做过测试的某个子集，以保证程序的变化没有带来非预 期的副作用。")]),_._v(" "),v("h3",{attrs:{id:"测试用例的定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#测试用例的定义"}},[_._v("#")]),_._v(" 测试用例的定义")]),_._v(" "),v("h5",{attrs:{id:"白盒测试："}},[v("a",{staticClass:"header-anchor",attrs:{href:"#白盒测试："}},[_._v("#")]),_._v(" 白盒测试：")]),_._v(" "),v("p",[_._v("测试用例：测试输入数据和预期的输出结果。")]),_._v(" "),v("h5",{attrs:{id:"黑盒测试："}},[v("a",{staticClass:"header-anchor",attrs:{href:"#黑盒测试："}},[_._v("#")]),_._v(" 黑盒测试：")]),_._v(" "),v("ul",[v("li",[_._v("等价类划分法")]),_._v(" "),v("li",[_._v("边界值分析法\n"),v("ul",[v("li",[_._v("输入等价类和输出等价类的边界就是应该着重测试的程序边界情况。选取的测 试数据应该刚好等于、刚好小于、刚好大于边界值")])])])]),_._v(" "),v("h3",{attrs:{id:"软件错误类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#软件错误类型"}},[_._v("#")]),_._v(" 软件错误类型")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("功能错(需求分析错误)")])]),_._v(" "),v("li",[v("p",[_._v("软件结构错")])]),_._v(" "),v("li",[v("p",[_._v("数据错")])]),_._v(" "),v("li",[v("p",[_._v("编码错")])]),_._v(" "),v("li",[v("p",[_._v("软件集成错")])]),_._v(" "),v("li",[v("p",[_._v("测试定义与测试执行错误")])])]),_._v(" "),v("h3",{attrs:{id:"软件可测试的特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#软件可测试的特性"}},[_._v("#")]),_._v(" 软件可测试的特性")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("可操作性")])]),_._v(" "),v("li",[v("strong",[_._v("可观察性")])]),_._v(" "),v("li",[v("strong",[_._v("可控制性")])]),_._v(" "),v("li",[v("strong",[_._v("可分解性")])]),_._v(" "),v("li",[v("strong",[_._v("简单易理解性")])])]),_._v(" "),v("p",[_._v("扩展（了解）")]),_._v(" "),v("ul",[v("li",[_._v("可控制性：是否可以将待测元件的状态控制到如测试条件要求。")]),_._v(" "),v("li",[_._v("可观察性：是否可以观察（中间或最后的）测试结果。")]),_._v(" "),v("li",[_._v("可隔离性：待测元件是否可以隔离测试。")]),_._v(" "),v("li",[v("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB",target:"_blank",rel:"noopener noreferrer"}},[_._v("关注点分离"),v("OutboundLink")],1),_._v("：待测元件是否有单一且清楚定义的任务。")]),_._v(" "),v("li",[_._v("易懂性：待测元件是否有说明文档，或是本身可读性很高。")]),_._v(" "),v("li",[_._v("可自动化性：待测元件是否可以自动测试。")]),_._v(" "),v("li",[_._v("异质性：是否需要不同的测试方法及工具平行测试。")])]),_._v(" "),v("h3",{attrs:{id:"调试时修改错误的原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#调试时修改错误的原则"}},[_._v("#")]),_._v(" 调试时修改错误的原则")]),_._v(" "),v("p",[_._v("修改错误的原则")]),_._v(" "),v("ul",[v("li",[_._v("在出现错误的地方，很有可能还有别的错误")]),_._v(" "),v("li",[_._v("修改错误的一个常见失误是只修改了这个错误的征兆或这个错误的表现，而没有修改错误的本身。")]),_._v(" "),v("li",[_._v("当心修正一个错误的同时有可能会引入新的错误")]),_._v(" "),v("li",[_._v("修改错误的过程将迫使人们暂时回到程序设计阶段")]),_._v(" "),v("li",[_._v("修改源代码程序，不要改变目标代码")])]),_._v(" "),v("p",[_._v("调试原则")]),_._v(" "),v("ul",[v("li",[_._v("在调试方面，许多原则本质上是心理学方面的问题，调试由两部分组成，调试原则也分成两组。")]),_._v(" "),v("li",[_._v("确定错误的性质和位置的原则")]),_._v(" "),v("li",[_._v("用头脑去分析思考与错误征兆有关的信息")]),_._v(" "),v("li",[_._v("避开死胡同")]),_._v(" "),v("li",[_._v("只把调试工具当做辅助手段来使用，利用调试工具，可以帮助思考，但不能代替思考")]),_._v(" "),v("li",[_._v("避免用试探法，最多只能把它当做最后手段")])]),_._v(" "),v("h3",{attrs:{id:"测试组件（单元测试）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#测试组件（单元测试）"}},[_._v("#")]),_._v(" 测试组件（单元测试）")]),_._v(" "),v("p",[_._v("单元测试（模块测试）：将每个模块作为一个单独的实体进行测试。发现的错误编码和详细设计阶段的错误")]),_._v(" "),v("p",[_._v("测试依据：详细设计文档")]),_._v(" "),v("p",[_._v("测试技术（设计测试用例的方法）：白盒测试技术")]),_._v(" "),v("p",[_._v("着重点:")]),_._v(" "),v("ol",[v("li",[_._v("模块接口")]),_._v(" "),v("li",[_._v("局部数据结构")]),_._v(" "),v("li",[_._v("重要的执行通路")]),_._v(" "),v("li",[_._v("出错处理通路")]),_._v(" "),v("li",[_._v("边界条件")])]),_._v(" "),v("h2",{attrs:{id:"第六章-软件维护"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第六章-软件维护"}},[_._v("#")]),_._v(" 第六章 软件维护")]),_._v(" "),v("h3",{attrs:{id:"软件维护的副作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#软件维护的副作用"}},[_._v("#")]),_._v(" 软件维护的副作用")]),_._v(" "),v("p",[_._v("编码、文档、数据的副作用")]),_._v(" "),v("p",[_._v("维护是为了延长软件的寿命，让软件创造更多的价值，但是维护会产生潜在的错误或\n其他不希望出现的情况，这称为维护的副作用。维护的副作用有编码副作用、数据副作用\n和文档副作用三种。")]),_._v(" "),v("p",[_._v("1．编码副作用")]),_._v(" "),v("p",[v("strong",[_._v("使用程序设计语言修改源程序时可能会引入错误")]),_._v("。在修改程序的标号、标识符、运算\n符、边界条件和程序的时序关系等时要特别仔细，避免引入新的错误。")]),_._v(" "),v("p",[_._v("2．数据副作用")]),_._v(" "),v("p",[v("strong",[_._v("修改数据结构时可能会造成软件设计与数据结构不匹配，因而导致软件错误")]),_._v("。如在修\n改局部量、全局量、记录或文件的格式、初始化控制或指针、输入输出或子程序的参数等\n时，容易导致设计与数据不一致。")]),_._v(" "),v("p",[_._v("3．文档副作用")]),_._v(" "),v("p",[v("strong",[_._v("对数据流、软件结构、模块逻辑或其他任何特性进行修改时，必须对相关的文档进行")]),_._v(" "),v("strong",[_._v("相应的修改，否则会导致文档与程序功能不匹配，文档不能反映软件当前的状态")]),_._v("。因此，\n必须在软件交付之前对软件配置进行评审，以减少文档的副作用。")]),_._v(" "),v("h2",{attrs:{id:"第八章-结构化方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第八章-结构化方法"}},[_._v("#")]),_._v(" 第八章 结构化方法")]),_._v(" "),v("h3",{attrs:{id:"dfd数据流图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dfd数据流图"}},[_._v("#")]),_._v(" DFD数据流图")]),_._v(" "),v("p",[_._v("描述信息流和数据从输入到"),v("strong",[_._v("输出过程")]),_._v("所经受的"),v("strong",[_._v("变换")]),_._v("。没有任何具体物理部件， 只是描绘数据在软件中"),v("strong",[_._v("流动")]),_._v("和"),v("strong",[_._v("被处理")]),_._v("的"),v("strong",[_._v("逻辑过程")]),_._v("。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305072014710.png",alt:"image-20230507201433883"}}),v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305072017492.png",alt:"image-20230507201712307"}}),v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305061649989.png",alt:"image-20230506164933741"}})]),_._v(" "),v("h3",{attrs:{id:"数据字典"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据字典"}},[_._v("#")]),_._v(" 数据字典")]),_._v(" "),v("p",[_._v("数据字典：是关于数据的信息集合，即对数据流图中包含的所有元素定义的集合。")]),_._v(" "),v("p",[_._v("1.数据字典的内容：数据流、数据流分量（数据元素）、数据存储、处理。")]),_._v(" "),v("p",[_._v("数据字典用途: 在软件分析和设计的过程中给人提供关于数据的描述信息。")]),_._v(" "),v("p",[_._v("① 作为分析阶段的工具")]),_._v(" "),v("p",[_._v("② 估计改变一个数据将产生的影响")]),_._v(" "),v("p",[_._v("③ 是数据库开发的第一步")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305061650107.png",alt:"image-20230506165036891"}}),v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305061651523.png",alt:"image-20230506165102431"}}),v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305061653076.png",alt:"image-20230506165341822"}})]),_._v(" "),v("h3",{attrs:{id:"结构化语言判定表判定数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#结构化语言判定表判定数"}},[_._v("#")]),_._v(" 结构化语言判定表判定数")]),_._v(" "),v("h3",{attrs:{id:"判断表判定树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#判断表判定树"}},[_._v("#")]),_._v(" 判断表判定树")]),_._v(" "),v("p",[_._v("判定表：当算法中包含多重嵌套的条件选择时判定表却能够清晰地表示复杂的条件组合与应做的动作之间的对应关系。")]),_._v(" "),v("p",[_._v("组成：")]),_._v(" "),v("ul",[v("li",[_._v("左上部列出所有条件,左下部是所有可能的动作。")]),_._v(" "),v("li",[_._v("右上部是表示各种条件组合,右下部是和每种条件组合相对应的动作。")])]),_._v(" "),v("p",[_._v("判定树")]),_._v(" "),v("p",[_._v("依据判断表来画")]),_._v(" "),v("p",[_._v("依据条件分类")]),_._v(" "),v("h3",{attrs:{id:"sc结构图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sc结构图"}},[_._v("#")]),_._v(" SC结构图")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305062051097.png",alt:"image-20230506205150739"}}),v("img",{attrs:{src:"https://shinoimg.yyshino.top/img/202305062052105.png",alt:"image-20230506205243117"}})]),_._v(" "),v("h4",{attrs:{id:"面向数据流设计方法也称为结构化设计方法（sd）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面向数据流设计方法也称为结构化设计方法（sd）"}},[_._v("#")]),_._v(" 面向数据流设计方法也称为结构化设计方法（SD）")]),_._v(" "),v("p",[_._v("数据流图分类")]),_._v(" "),v("p",[_._v("（1）变换流：由输入、变换中心和输出三部分组成。")]),_._v(" "),v("p",[_._v("（2）事务流：在多种事务中选择一个执行。")]),_._v(" "),v("p",[_._v("变换分析: 把具有变换流特点的数据流图映射成软件结构。")]),_._v(" "),v("h3",{attrs:{id:"变换型数据流图-软件结构图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#变换型数据流图-软件结构图"}},[_._v("#")]),_._v(" 变换型数据流图 => 软件结构图")]),_._v(" "),v("h3",{attrs:{id:"事物型数据流图-软件结构图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事物型数据流图-软件结构图"}},[_._v("#")]),_._v(" 事物型数据流图 => 软件结构图")])])}),[],!1,null,null,null);v.default=a.exports}}]);