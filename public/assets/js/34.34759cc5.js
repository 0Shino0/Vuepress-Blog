(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{623:function(t,a,s){"use strict";s.r(a);var v=s(1),_=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"},[t._v("SSR服务端渲染")])]),t._v(" "),a("h2",{attrs:{id:"ssr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ssr"}},[t._v("#")]),t._v(" SSR")]),t._v(" "),a("h3",{attrs:{id:"传统的服务端渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传统的服务端渲染"}},[t._v("#")]),t._v(" 传统的服务端渲染")]),t._v(" "),a("p",[t._v("传统的服务端渲染有: asp,jsp,ejs等,服务端语言往往通过这些模板引擎将数据和do在服务端渲染完成,返回一个完整的静态html页面给客户端,由客户端直接显示。")]),t._v(" "),a("h4",{attrs:{id:"原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),a("ol",[a("li",[t._v("客户端发送http请求")]),t._v(" "),a("li",[t._v("服务端响应http请求，返回拼接好的html字符串给客户端")]),t._v(" "),a("li",[t._v("3.客户端渲染html")])]),t._v(" "),a("h4",{attrs:{id:"缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),a("ul",[a("li",[t._v("前后端不分离,不好维护")]),t._v(" "),a("li",[t._v("用户体验不佳,需要重新加载页面")]),t._v(" "),a("li",[t._v("服务端压力大")])]),t._v(" "),a("h3",{attrs:{id:"csr-客户端渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#csr-客户端渲染"}},[t._v("#")]),t._v(" CSR(客户端渲染)")]),t._v(" "),a("p",[t._v("在现代化的前端项目中，客户端渲染的代表性技术栈是vue、react、angular，我们常常使用它们来构建客户端单页或者多页应用程序。以SPA构建程序为例，在浏览器端首先渲染的是一套空的html,通过JS直接进行页面的渲染和路由跳转等操作,所有的数据通过ajax请求从服务器获取后,在进行客户端的拼装和展示。")]),t._v(" "),a("h4",{attrs:{id:"原理-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理-2"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),a("ol",[a("li",[t._v("客户端发起http请求")]),t._v(" "),a("li",[t._v("服务端响应http请求，返回一个空的html文件")]),t._v(" "),a("li",[t._v("客户端初始化时加载必须的js文件,请求接口")]),t._v(" "),a("li",[t._v("将生成的dom插入到html中")])]),t._v(" "),a("h4",{attrs:{id:"缺点-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),a("ul",[a("li",[t._v("首屏加载慢")]),t._v(" "),a("li",[t._v("不利于SEO")])]),t._v(" "),a("h3",{attrs:{id:"同构（现代服务器渲染）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同构（现代服务器渲染）"}},[t._v("#")]),t._v(" 同构（现代服务器渲染）")]),t._v(" "),a("p",[t._v("Vue、 React的SSR方案实际上就是同构渲染,我们现在讲的服务端渲染概念,是指在前端范畴或者说在vue,react等单页面技术栈范畴内,基于Node.js server运行环境的服务端渲染方案,通过在Node.js中运行相同应用程序的前端框架(例如React, Vue等) ,将其预渲染成HTML,最后在客户端进行注水化处理。简单来讲,就是应用程序的大部分代码在服务器(node服务端)和客户端上运行,这就是所谓的现代服务端渲染:同构。")]),t._v(" "),a("h4",{attrs:{id:"原理-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理-3"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),a("ol",[a("li",[t._v("客户端发起http请求")]),t._v(" "),a("li",[t._v("服务端渲染把Vue实例转换成了静态的html发送给客户端")]),t._v(" "),a("li",[t._v("客户端渲染是需要把事件、响应式特性等Vue的特性都绑回去")])]),t._v(" "),a("h4",{attrs:{id:"缺点-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点-3"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),a("ul",[a("li",[t._v("服务器压力大")]),t._v(" "),a("li",[t._v("涉及构建设置和部署的更多要求")]),t._v(" "),a("li",[t._v("一些三方库可能需要特殊处理")])]),t._v(" "),a("h4",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),a("ul",[a("li",[t._v("首屏速度快")]),t._v(" "),a("li",[t._v("前后端分离")]),t._v(" "),a("li",[t._v("利于SEO")]),t._v(" "),a("li",[t._v("有一些现成框架: "),a("code",[t._v("Nuxt.js")]),t._v("、 "),a("code",[t._v("Next.js")])])]),t._v(" "),a("h2",{attrs:{id:"csr、ssr以及同构渲染的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#csr、ssr以及同构渲染的区别"}},[t._v("#")]),t._v(" CSR、SSR以及同构渲染的区别")]),t._v(" "),a("h2",{attrs:{id:"nuxt3-基本原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nuxt3-基本原理"}},[t._v("#")]),t._v(" Nuxt3 基本原理")]),t._v(" "),a("h2",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])])])}),[],!1,null,null,null);a.default=_.exports}}]);